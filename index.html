<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU TUI Demo with Font</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #2d2d2d;
        }
        canvas {
            background: black;
            border: 1px solid #666;
        }
        #status {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="status">Initializing WebGPU...</div>
    <script>
        function createFontTexture(device) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const charWidth = 8;
            const charHeight = 16;
            canvas.width = charWidth * 16;  // 16 chars per row
            canvas.height = charHeight * 16; // 16 rows
            
            ctx.fillStyle = 'white';
            ctx.font = '16px monospace';
            ctx.textBaseline = 'top';

            for (let i = 32; i < 127; i++) {
                const x = (i - 32) % 16;
                const y = Math.floor((i - 32) / 16);
                ctx.fillText(String.fromCharCode(i), 
                    x * charWidth, y * charHeight);
            }

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = new Uint8Array(imageData.data);

            const texture = device.createTexture({
                size: [canvas.width, canvas.height, 1],
                format: 'rgba8unorm',
                usage: GPUTextureUsage.TEXTURE_BINDING | 
                       GPUTextureUsage.COPY_DST | 
                       GPUTextureUsage.RENDER_ATTACHMENT
            });

            device.queue.writeTexture(
                { texture: texture },
                data,
                { bytesPerRow: canvas.width * 4 },
                [canvas.width, canvas.height]
            );

            return texture;
        }

        class WebGPUTUI {
            constructor(canvas, width, height) {
                this.canvas = canvas;
                this.width = width;
                this.height = height;
                this.device = null;
                this.context = null;
                this.pipeline = null;
                this.fontTexture = null;
                this.sampler = null;
                this.textGrid = Array(height).fill().map(() => Array(width).fill(' '));
                this.colorGrid = Array(height).fill().map(() => Array(width).fill([1.0, 1.0, 1.0, 1.0]));
            }

            async initialize() {
                if (!navigator.gpu) {
                    throw new Error('WebGPU not supported');
                }

                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    throw new Error('No appropriate GPU adapter found');
                }

                this.device = await adapter.requestDevice();
                this.context = this.canvas.getContext('webgpu');

                const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
                this.context.configure({
                    device: this.device,
                    format: canvasFormat,
                    alphaMode: 'premultiplied',
                });

                this.fontTexture = createFontTexture(this.device);
                this.sampler = this.device.createSampler({
                    magFilter: 'nearest',
                    minFilter: 'nearest',
                });

                const shaderModule = this.device.createShaderModule({
                    code: `
                        struct VertexOutput {
                            @builtin(position) position: vec4f,
                            @location(0) texCoord: vec2f,
                            @location(1) color: vec4f,
                            @location(2) charCoord: vec2f,
                        };

                        @group(0) @binding(0) var<uniform> fontAtlas: vec4f;
                        @group(0) @binding(1) var fontTexture: texture_2d<f32>;
                        @group(0) @binding(2) var fontSampler: sampler;

                        @vertex
                        fn vertexMain(
                            @location(0) position: vec2f,
                            @location(1) texCoord: vec2f,
                            @location(2) color: vec4f,
                            @location(3) charCoord: vec2f,
                        ) -> VertexOutput {
                            var output: VertexOutput;
                            output.position = vec4f(position, 0.0, 1.0);
                            output.texCoord = texCoord;
                            output.color = color;
                            output.charCoord = charCoord;
                            return output;
                        }

                        @fragment
                        fn fragmentMain(
                            @location(0) texCoord: vec2f,
                            @location(1) color: vec4f,
                            @location(2) charCoord: vec2f,
                        ) -> @location(0) vec4f {
                            let charPos = charCoord + texCoord * vec2f(1.0/16.0, 1.0/16.0);
                            let fontColor = textureSample(fontTexture, fontSampler, charPos);
                            return color * fontColor.r;
                        }
                    `
                });

                const bindGroupLayout = this.device.createBindGroupLayout({
                    entries: [
                        {
                            binding: 0,
                            visibility: GPUShaderStage.FRAGMENT,
                            buffer: { type: 'uniform' }
                        },
                        {
                            binding: 1,
                            visibility: GPUShaderStage.FRAGMENT,
                            texture: { sampleType: 'float' }
                        },
                        {
                            binding: 2,
                            visibility: GPUShaderStage.FRAGMENT,
                            sampler: { type: 'filtering' }
                        }
                    ]
                });

                const pipelineLayout = this.device.createPipelineLayout({
                    bindGroupLayouts: [bindGroupLayout]
                });

                this.pipeline = this.device.createRenderPipeline({
                    layout: pipelineLayout,
                    vertex: {
                        module: shaderModule,
                        entryPoint: 'vertexMain',
                        buffers: [
                            {
                                arrayStride: 40,
                                attributes: [
                                    {
                                        shaderLocation: 0,
                                        offset: 0,
                                        format: 'float32x2',
                                    },
                                    {
                                        shaderLocation: 1,
                                        offset: 8,
                                        format: 'float32x2',
                                    },
                                    {
                                        shaderLocation: 2,
                                        offset: 16,
                                        format: 'float32x4',
                                    },
                                    {
                                        shaderLocation: 3,
                                        offset: 32,
                                        format: 'float32x2',
                                    }
                                ],
                            },
                        ],
                    },
                    fragment: {
                        module: shaderModule,
                        entryPoint: 'fragmentMain',
                        targets: [
                            {
                                format: canvasFormat,
                                blend: {
                                    color: {
                                        srcFactor: 'src-alpha',
                                        dstFactor: 'one-minus-src-alpha',
                                    },
                                    alpha: {
                                        srcFactor: 'src-alpha',
                                        dstFactor: 'one-minus-src-alpha',
                                    },
                                },
                            },
                        ],
                    },
                    primitive: {
                        topology: 'triangle-list',
                    },
                });

                this.uniformBuffer = this.device.createBuffer({
                    size: 16,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });

                this.device.queue.writeBuffer(
                    this.uniformBuffer,
                    0,
                    new Float32Array([8/128, 16/128, 0, 0])
                );

                this.bindGroup = this.device.createBindGroup({
                    layout: bindGroupLayout,
                    entries: [
                        {
                            binding: 0,
                            resource: { buffer: this.uniformBuffer }
                        },
                        {
                            binding: 1,
                            resource: this.fontTexture.createView()
                        },
                        {
                            binding: 2,
                            resource: this.sampler
                        }
                    ]
                });
            }

            setText(x, y, text, color = [1.0, 1.0, 1.0, 1.0]) {
                if (y >= 0 && y < this.height) {
                    const chars = [...text];
                    for (let i = 0; i < chars.length; i++) {
                        if (x + i >= 0 && x + i < this.width) {
                            this.textGrid[y][x + i] = chars[i];
                            this.colorGrid[y][x + i] = color;
                        }
                    }
                }
            }

            createCharQuad(char, x, y, color) {
                const cellWidth = 2.0 / this.width;
                const cellHeight = 2.0 / this.height;
                const xPos = (x / this.width) * 2 - 1;
                const yPos = 1 - (y / this.height) * 2;
                
                const charCode = char.charCodeAt(0) - 32;
                const charX = (charCode % 16) / 16;
                const charY = Math.floor(charCode / 16) / 16;

                return new Float32Array([
                    xPos, yPos,                 0, 0, ...color, charX, charY,
                    xPos + cellWidth, yPos,     1, 0, ...color, charX, charY,
                    xPos, yPos - cellHeight,    0, 1, ...color, charX, charY,
                    xPos + cellWidth, yPos,     1, 0, ...color, charX, charY,
                    xPos + cellWidth, yPos - cellHeight, 1, 1, ...color, charX, charY,
                    xPos, yPos - cellHeight,    0, 1, ...color, charX, charY,
                ]);
            }

            async render() {
                const commandEncoder = this.device.createCommandEncoder();
                const textureView = this.context.getCurrentTexture().createView();

                const renderPassDescriptor = {
                    colorAttachments: [
                        {
                            view: textureView,
                            clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
                            loadOp: 'clear',
                            storeOp: 'store',
                        },
                    ],
                };

                const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
                passEncoder.setPipeline(this.pipeline);
                passEncoder.setBindGroup(0, this.bindGroup);

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const char = this.textGrid[y][x];
                        if (char !== ' ') {
                            const vertexData = this.createCharQuad(char, x, y, this.colorGrid[y][x]);
                            const buffer = this.device.createBuffer({
                                size: vertexData.byteLength,
                                usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                            });
                            this.device.queue.writeBuffer(buffer, 0, vertexData);
                            passEncoder.setVertexBuffer(0, buffer);
                            passEncoder.draw(6, 1, 0, 0);
                        }
                    }
                }

                passEncoder.end();
                this.device.queue.submit([commandEncoder.finish()]);
            }
        }

        async function main() {
            const statusEl = document.getElementById('status');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                document.body.appendChild(canvas);

                const tui = new WebGPUTUI(canvas, 80, 30);
                await tui.initialize();
                
                statusEl.textContent = 'WebGPU initialized successfully!';
                setTimeout(() => statusEl.style.display = 'none', 2000);

                tui.setText(0, 0, "Sample WebGPU TUI", [1.0, 1.0, 0.0, 1.0]);
                tui.setText(2, 2, "Press any key to continue...", [0.0, 1.0, 0.0, 1.0]);
                tui.setText(4, 4, "Type something:", [1.0, 0.0, 1.0, 1.0]);

                let inputText = '';
                let inputY = 4;
                let inputX = 19;

                document.addEventListener('keydown', (event) => {
                    if (event.key.length === 1) {
                        inputText += event.key;
                        tui.setText(inputX, inputY, event.key, [1.0, 1.0, 1.0, 1.0]);
                        inputX++;
                    } else if (event.key === 'Enter') {
                        inputY += 2;
                        inputX = 4;
                        inputText = '';
                    } else if (event.key === 'Backspace' && inputText.length > 0) {
                        inputText = inputText.slice(0, -1);
                        inputX--;
                        tui.setText(inputX, inputY, ' ', [1.0, 1.0, 1.0, 1.0]);
                    }
                });

                function render() {
                    tui.render();
                    requestAnimationFrame(render);
                }
                render();

            } catch (error) {
                statusEl.textContent = 'Error: ' + error.message;
                statusEl.style.color = 'red';
            }
        }

        main();
    </script>
</body>
</html>
